buildscript {
    ext { springBootVersion = '1.5.2.RELEASE' }
    repositories {
        jcenter()
        maven { url "https://plugins.gradle.org/m2/" }
    }
    dependencies {
        classpath("org.springframework.boot:spring-boot-gradle-plugin:${springBootVersion}")
        classpath('gradle.plugin.com.gorylenko.gradle-git-properties:gradle-git-properties:1.4.17')
        classpath 'co.riiid:gradle-github-plugin:0.4.2'
    }
}

apply plugin: 'java'
apply plugin: 'eclipse'
apply plugin: 'idea'
apply plugin: 'maven'
apply plugin: 'org.springframework.boot'
apply plugin: 'announce'
apply plugin: 'jacoco'
apply plugin: 'co.riiid.gradle'


group = 'au.com.mountainpass'

import org.apache.commons.lang.NotImplementedException;

def shippable = System.env.SHIPPABLE != 'true'
if( shippable ) {
    try {
        new URL("https://api.github.com/repos/mountain-pass/ryvr/releases/latest").withInputStream{ i ->
            throw new NotImplementedException();
        }
    }
    catch(e) {
        println "Error Getting Latest version for ${name}: ${e}"
        project.version = '1.0.0'
    }
}
else {
    project.version = 'LOCAL'
}

println "${project.name} version: ${project.version}"

task printVersion << { println "${project.name} version: ${getNextVersion()}" }



sourceCompatibility = 1.8
targetCompatibility = 1.8

compileJava.options.compilerArgs.add '-parameters'
compileTestJava.options.compilerArgs.add '-parameters'

repositories {
    mavenLocal()
    jcenter()
    // codacy uses com.typesafe.netty:netty-http-pipelining, which
    // can be found here
    maven { url "http://dl.bintray.com/typesafe/maven-releases" }
}

eclipseProject {
    doLast {
        // https://discuss.gradle.org/t/how-to-write-properties-to-3rd-party-eclipse-settings-files/6499/2

        def props = new Properties()
        file(".settings/org.eclipse.jdt.core.prefs").withInputStream { stream ->
            props.load(stream)
        }
        props.setProperty("org.eclipse.jdt.core.compiler.codegen.methodParameters", "generate")
        file(".settings/org.eclipse.jdt.core.prefs").withOutputStream { stream ->
            props.store(stream, null)
        }
    }
}

springBoot  { buildInfo() }

task sourcesJar(type: Jar, dependsOn: classes) {
    classifier = 'sources'
    from sourceSets.main.allSource
}

artifacts { archives sourcesJar  }

configurations {
    providedRuntime
    codacy
}


dependencies {
    compile('commons-lang:commons-lang:2.6')
    compile('commons-io:commons-io:2.5')

    compile('org.springframework.boot:spring-boot-starter-actuator')
    compile('org.springframework.boot:spring-boot-starter-web') //{ exclude(module: 'spring-boot-starter-tomcat') } compile('org.springframework.boot:spring-boot-starter-undertow')
    compile('org.springframework.boot:spring-boot-starter-jdbc')
    compile('org.springframework.boot:spring-boot-autoconfigure')


    compile('com.github.spullara.mustache.java:compiler:0.9.2')

    compile("org.springframework.boot:spring-boot-devtools")


    compile 'de.otto.edison:edison-hal:1.0.0.RC5'

    compile group: 'org.webjars', name: 'swagger-ui', version: '2.2.10'

    compile group: 'ch.qos.logback', name: 'logback-classic', version: '1.2.1'
    compile group: 'ch.qos.logback', name: 'logback-core', version: '1.2.1'

    compile('org.apache.httpcomponents:httpasyncclient')

    compile('org.webjars:bootstrap:3.3.7-1')
    compile('org.webjars:jquery:3.1.1-1')
    compile('org.webjars.bower:angularjs:1.6.0')

    compile group: 'org.shredzone.acme4j', name: 'acme4j-client', version: '0.10'
    compile 'org.bouncycastle:bcpkix-jdk15on:1.56'


    testCompile('org.springframework.boot:spring-boot-starter-test')
    testCompile group: 'info.cukes', name: 'cucumber-junit', version:'1.2.5'
    testCompile group: 'info.cukes', name: 'cucumber-spring', version:'1.2.5'

    testCompile ('org.seleniumhq.selenium:selenium-java:3.0.1') { exclude(module: 'commons-logging') }
    testCompile 'org.seleniumhq.selenium:selenium-firefox-driver:3.0.1'
    testCompile 'com.saucelabs:sauce_junit:2.1.20'
    testCompile 'com.saucelabs:ci-sauce:1.123'


    testCompile('io.swagger:swagger-parser:1.0.22')

    testCompile group: 'io.prometheus', name: 'simpleclient', version: '0.0.21'


    compile('com.h2database:h2')
    compile group: 'mysql', name: 'mysql-connector-java', version: '5.1.39'
    compile group: 'org.postgresql', name: 'postgresql', version: '42.1.1'




    codacy group: 'com.codacy', name: 'codacy-coverage-reporter', version: '1.0.10'
}


//bootRun {
//    args "--spring.config.location=build/bootrun/application.properties"
//}
bootRun {
    String activeProfile =  System.properties['spring.profiles.active']
    String confLoc = System.properties['spring.config.location']
    systemProperty "spring.profiles.active", activeProfile
    systemProperty "spring.config.location", confLoc
    //    if ( project.hasProperty('jvmArgs') ) {
    //        jvmArgs = ["-Dserver.ssl.key-store: ${buildDir}/keystore.jks"]
    //        jvmArgs.addAll(project.jvmArgs.split("\\s+") as List)
    //    }
}

test { exclude '**' }

new ByteArrayOutputStream().withStream { os ->
    def result = exec {
        executable = 'whoami'
        standardOutput = os
    }
    ext.whoami = os.toString().trim()
}

if(file("gradle-${whoami}.properties").exists()) {
    file("gradle-${whoami}.properties").withReader { reader ->
        def userProps = new Properties()
        userProps.load(reader)
        userProps.each { prop ->
            project.ext.set(prop.key, prop.value)
        }
    }
}


def testOutputDir = project.getProperties().get("testOutputDir") ?: "${buildDir}"
def coverageOutputDir = project.getProperties().get("coverageOutputDir") ?: "${buildDir}"
def SAUCE_LABS_USERNAME = project.getProperties().get("SAUCE_LABS_USERNAME") ?: ""
def SAUCE_LABS_KEY = project.getProperties().get("SAUCE_LABS_KEY") ?: ""
Boolean withSauce = project.getProperties().get("withSauce") ?: false

jacoco {
    toolVersion = "0.7.7.201606060606"
    reportsDir = file("${buildDir}/test-results/jacoco")
}


def testClasses = fileTree("src/test/java") {
    // include { details -> details.file.text.contains('@RunWith(SpringProfileCucumber.class)') }
    include '**/*Tests*.java'
    exclude '**/*_Current.java'
}

testClasses.each { File testClass ->
    println testClass
    def baseName = testClass.name.replace('.java', '')
    println baseName
    task "test${baseName}"(type: Test, group: 'verification', description: "run ${baseName}") {
        testClassesDir = sourceSets.test.output.classesDir
        classpath = sourceSets.test.runtimeClasspath
        include "**/${baseName}.class"
        ext.outputDir = "${testOutputDir}/test-results-${baseName}"
        outputs.dir file(outputDir)
        ext.coverageDir = "${coverageOutputDir}/coverage-results-${baseName}"
        outputs.dir file(coverageDir)
        systemProperty 'cucumber.options',  "--plugin json:${outputDir}/cucumber.json --plugin html:${outputDir}/html --plugin junit:${outputDir}/TEST-cucumber.xml"
        systemProperty 'webdriver.sauce.labs.username',  "${SAUCE_LABS_USERNAME}"
        systemProperty 'webdriver.sauce.labs.key',  "${SAUCE_LABS_KEY}"
        jacoco {
            append = false
            destinationFile = file("${coverageDir}/jacoco/${baseName}.exec")
        }

        ignoreFailures = true
    }
    tasks["test${baseName}"].finalizedBy jacocoTestReport
}

test { ignoreFailures = true }

test.dependsOn {
    tasks.findAll { task ->
        //    println "${task.name}.local: ${project.ext.properties["${task.name}.local"]}"
        //    println 'task.name.startsWith(\'test\')?: ' +         task.name.startsWith('test')
        //    println 'task.name != "test"?: ' +        task.name != "test"
        //    println 'project.hasProperty("${task.name}.local")?: ' +         project.hasProperty("${task.name}.local")
        //    println 'project.ext.properties["${task.name}.local"]?: ' +          project.ext.properties["${task.name}.local"]=='true'
        //    println 'test?: ' +        ( task.name.startsWith('test') && task.name != "test" && project.hasProperty("${task.name}.local") && project.ext.properties["${task.name}.local"]=='true' )
        //
        task.name.startsWith('test') && task.name != "test" && project.hasProperty("${task.name}.enabled") && project.ext.properties["${task.name}.enabled"]=='true' }
}


jacocoTestReport {
    executionData = fileTree(dir: "${coverageOutputDir}", include: '**/jacoco/*.exec')

    reports {
        xml.enabled true
        xml.destination "${coverageOutputDir}/coverage-results/jacoco/${archivesBaseName}.xml"
        csv.enabled false
        html.enabled true
        html.destination "${coverageOutputDir}/coverage-results/jacoco/html"
    }

    doLast {
        def report = reports.xml.destination
        logger.lifecycle("Checking coverage results: ${report}")

        def parser = new XmlParser()
        parser.setFeature("http://apache.org/xml/features/nonvalidating/load-external-dtd", false);
        parser.setFeature("http://apache.org/xml/features/disallow-doctype-decl", false)
        def results = parser.parse(report)

        def percentage = {
            if( it == null ) {
                return 100
            }
            def covered = it.'@covered' as Double
            def missed = it.'@missed' as Double
            ((covered / (covered + missed)) * 100).round(2)
        }

        def counters = results.counter
        def metrics = [:]
        metrics << [
            'instruction': percentage(counters.find { it.'@type'.equals('INSTRUCTION') }),
            'branch'     : percentage(counters.find { it.'@type'.equals('BRANCH') }),
            'line'       : percentage(counters.find { it.'@type'.equals('LINE') }),
            'complexity' : percentage(counters.find { it.'@type'.equals('COMPLEXITY') }),
            'method'     : percentage(counters.find { it.'@type'.equals('METHOD') }),
            'class'      : percentage(counters.find { it.'@type'.equals('CLASS') })
        ]


        def failures = []
        def success = []
        metrics.each {
            def limit = limits[it.key]
            if (it.value < limit) {
                failures.add("- ${it.key} coverage rate is: ${it.value}%, minimum is ${limit}%")
            }
            else {
                success.add("- ${it.key} coverage rate is: ${it.value}%, minimum is ${limit}%")
            }
        }

        logger.quiet("------------------ Code Coverage Passes -----------------------")
        success.each { logger.quiet(it) }
        logger.quiet("---------------------------------------------------------------")
        if (failures) {
            logger.quiet("------------------ Code Coverage Failed -----------------------")
            failures.each { logger.quiet(it) }
            logger.quiet("---------------------------------------------------------------")
            throw new GradleException("Code coverage failed")
        } else{
            logger.quiet("Passed Code Coverage Checks")
        }
    }
}

ext {
    // TODO: Increase these
    limits = [
        'instruction': 70,
        'branch'     : 70,
        'line'       : 70,
        'complexity' : 70,
        'method'     : 70,
        'class'      : 70
    ]
}




task uploadCoverageToCodacy(type: JavaExec, dependsOn : jacocoTestReport) {
    main = "com.codacy.CodacyCoverageReporter"
    classpath = configurations.codacy
    args = [
        "-l",
        "Java",
        "-r",
        "${coverageOutputDir}/coverage-results/jacoco/${archivesBaseName}.xml"
    ]
}

jar {
    manifest {
        attributes("Implementation-Title": "Ryvr",
        "Implementation-Version": version)
    }
}

github {
    owner = 'mountain-pass'
    repo = 'ryvr'
    token = project.hasProperty('githubToken') ? project.getProperty('githubToken') : 'NOTSET'
    tagName = "${project.version}"
    targetCommitish = 'master'
    name = "v${project.version}"
    body = file("RELEASE_NOTES-v${project.version}.md").text
    assets = [
        "build/libs/ryvr-1.0.0.jar"
    ]
    prerelease = false
    draft = false
}


githubRelease.dependsOn bootRepackage

gradle.taskGraph.afterTask { Task task, TaskState state ->
    if (state.failure) {
        announce.announce("':${task.name}' FAILED", "local")
    }
    else {
        announce.announce("':${task.name}' succeeded", "local")
    }
}

